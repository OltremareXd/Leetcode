# 63.不同路径 II

解题思路：和不同路径I相同，状态转移方程不变，得到最终路径总数的方法不变，只是增加了障碍物这一条件，则在使用状态转移方程时，需要增加判断障碍物这一条件来更新每次的路径总数。但这个方法会遇到很多边界情况需要自行处理，在解题时，可能会造成时间的浪费，所以不推荐。

另一个思路，只使用一维数组来记录每一个格子的路径总数，并与前一个格子的路径总数相加，得到现在格子的路径总数，这样即不需要考虑过多的边界情况，又能够简洁地解题。

1.定义一个dp数组，长度为网格的列数，并且第一格置为1；

2.循环网格中每个格子和其所在的列数，因为我们的dp数组记录的是每列格子的路径。

3.判断当前格子是否有障碍，若有，则dp数组的当前列置为0，若没有，则判断是否为第一格，若是则不作处理，否则，将其与前一个格子的值相加；

4.最终，dp的最后一个结果为答案

代码如下：

```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid) -> int:
        dp = [0] * len(obstacleGrid[0])
        dp[0] = 1
        for r in range(len(obstacleGrid)):
            for c, x in enumerate(obstacleGrid[r]):
                if x != 1:
                    if c != 0:
                        dp[c] += dp[c - 1]
                else:
                    dp[c] = 0
        return dp[-1]
```
